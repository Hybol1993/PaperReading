scalable commytativity rule 阅读报告
=============
<center>毛海宇    2015310607</center>


## 问题提出 ##
   一般情况下，研究者如何评价一个多核软件的扩展性呢？主要有一下几个步骤：
   >1. 选一个的靠谱的workload
   >2. plot 核数变化过程中performance的差异
   >3. 使用profile 工具来寻找扩展过程中的bottleneck
   
可以看到的是这种方式是跟实际存在的具体问题相关，那么这样思路是缺乏通用性的，也就是说针对不同的Workload或者核数变多就会产生新的bottleneck.
   
这篇论文采用一个全新的思路来解决这种扩展性通用的问题，从高层次－软件接口出发。 这就使得扩展性有可能出现在应用程序实现之前，出现在必要的硬件去测量这种实现的扩展性之前。 它重点关心内在的扩展性问题的本身，这样也就导致了需要对现有接口进行改进，设计一种全新的可扩展的接口。
 
##设计思想##

扩展性通常会作为一种实现的属性，而不是一个接口属性。因为扩展性依赖于硬件。 而事实上，假设一种多核共享mem的场景，类似于MESI的协议来维护cache 的一致性，那么通用的可扩展性就成为了可能。

我们通常提到一组操作可扩展，如果它们的实现在内存访问的过程中不存在冲突，也就是conflict-free.当内存访问不存在冲突的时候，增加核数对性能就会产生线性提升。 虽然在实际复杂的硬件设计中并不是非常完美的模型，但是这却是一种非常好的假设。

那么论文提到的方法的核心思想一种可扩展可交换性规则的设计。
这是什么意思呢？这个规则就是，在任何场景下，都不可以使用接口来区分操作之间的执行顺序。而接口的实现在这些操作的过程中都不存在内存访问冲突。 用更简洁的话说，就是无论接口操作怎么交换，它们的实现都会是可扩展的。

##论文的主要贡献##

1. 提出了一种扩展交换性规则，形式化这个规则，并给出了理论证明，确保其正确性。是一种状态独立，基于接口的可交换性。
2. 设计实现了一个自动测试扩展性的工具COMMUTER
3. 设计实现了一个可扩展的拥有类似POSIX的内核。


## COMMUTER 设计##

 为了验证形式化规则的正确性，作者设计实现了一个自动测试扩展性的工具COMMUTER，工具分为三个部分：
 
> * 分析器，抽象出一个接口模型，精确计算出接口操作可交换的的条件。
> * 测试用例生成器，根据分析器计算出来的条件，生成出针对接口模型的可交换的实际操作集用例
> * 内存监测，用来检查每个测试用例是不是一种无内存冲突的特殊实现。

为了说明COMMUTER对内核开发者是否有用，作者还在COMMUTER中设计了一些POSIX文件系统和虚拟内存调用，借此以评价linux的可扩展性，同时用以开发一个可扩展的文件和虚拟内存系统（在SV6内核的基础上）


## COMMTER的测试##

作者在论文中说明了COMMUTER的用例生成方法，和生成用例的类型。测试了现有POSIX接口实现在COMMUTER测试中的结果，同时与作者自己设计并实现的SV6系统的测试情况进行了对比。

结果显示，在产生的13364个测试用例中，Linux系统有9386个用例具有较好可扩展性，而SV6系统有13528个用例具有较好可扩展性。


## 硬件上的测试##

为了说明无可交换规则在硬件上也限制了程序性能，作者也在一台80核的机器上做了对比实验，分别使用两种系统，一种是标准的，带有无可交换规则的POSIX API的系统，另一种是作者设计修改的，带有符合可交换性API的系统。测试用的BenchMark是Microbenchmarks, 作者设计系统在BenchMark的测试中，都表现出了很好可扩展性。






